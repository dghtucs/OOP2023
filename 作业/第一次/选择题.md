
# 1
A. ls -a

在Unix或类Unix的操作系统（如Linux或Mac OS）中，`ls`是一个基础命令，用于列出目录的内容。参数`-a`使得`ls`命令能够显示包括隐藏文件在内的所有文件和文件夹。隐藏文件通常以`.`开头。

其他选项的含义如下：

B. `ls -l`：显示详细列表，包括文件/文件夹的权限，所有者，大小，修改日期等。

C. `ls -r`：逆序排列文件或文件夹。

D. `ls -t`：根据修改时间排序文件和文件夹，最新的文件或文件夹首先被列出。

# 2
【多选】假设你有一个C++源代码文件 test.cpp，其中包含以下内容：

#include <iostream>

using namespace std;

int main() {
    int a = 123;
    cout << "The value of a is: " << a << endl;
    return 0;
}
下面那条命令可以正确生成可执行文件？

A. g++ -o test test.cpp

B. g++ test.cpp -o test

C. g++ -c test.cpp -o test

D. g++ -o test.cpp test

A. g++ -o test test.cpp

B. g++ test.cpp -o test

在这个例子中，选项A和B都是正确的。`g++`是用于编译C++代码的GNU编译器。`-o`选项用于指定输出的可执行文件名。

选项C，`g++ -c test.cpp -o test`，会产生一个名为"test"的对象文件，而不是可执行文件。`-c`选项告诉编译器只生成对象文件。

选项D，`g++ -o test.cpp test`，这个命令会尝试把"test"这个文件（如果它存在的话）编译并生成一个名为"test.cpp"的可执行文件。这可能会覆盖你的源代码文件，因此通常不会这么使用。


# 3
有以下两个文件代码段，分别保存在 file1.cpp 和 file2.cpp 文件中：

 // File: file1.cpp
 #include <iostream>
 extern int x;

 void foo() {
     int x;
     x = 10;
 }

 int main() {
     foo();
     std::cout << "x = " << x << std::endl;
     return 0;
 }
 // File: file2.cpp
 int x;
使用 g++ file1.cpp file2.cpp -o main 编译，如果编译成功则运行 ./main，以下说法正确的是：

A. 编译错误

B. 运行错误

C. 运行输出"x = 0"

D. 运行输出"x = 10"
answer
C. 运行输出"x = 0"

在这个例子中，file1.cpp 中的 `extern int x;` 声明了一个外部的整数变量x，其定义在其他文件中，即file2.cpp中的 `int x;`。这就是说，这两个x实际上是同一个变量。然而，在file1.cpp中的foo函数内，我们又定义了一个局部变量x，它只在foo函数内可见，而且这个局部变量x隐藏了外部的同名变量x。

因此，当我们在main函数中调用foo函数时，虽然改变了局部变量x的值，但并没有改变全局变量x的值。所以，当我们输出x的值时，我们实际上输出的是全局变量x的值，它的初始值默认为0（如果没有明确初始化，全局/静态变量会被初始化为0）。所以选项C是正确的。

选项A和B都是错误的，因为这两个文件都可以正常编译和运行。

选项D也是错误的，因为尽管我们改变了局部变量x的值，但全局变量x的值并未改变。


# 4
这段代码运行后，输出结果是什么？

#include <iostream>
 
using namespace std;

#define Max(a, b) (a > b ? a : b)

int main(){
    
    int i = 1;
    i = i++;
    cout << Max(++i, 1) << endl;
    
    return 0;
}
A. 1

B. 2

C. 3

D. 4


answer
C. 3

首先，这段代码中，`i = i++;` 是未定义的行为，因为它违反了顺序点规则。在C++中，对于一个变量，修改和访问的顺序在一个表达式中没有明确的顺序。这是一个常见的错误，应该避免这种形式。

然而，假设这段代码的行为是确定的，并且 `i = i++;` 等同于 `i = i; i++;`，那么，我们有如下情况：初始化 `i = 1;` ，然后 `i = i++;` 并没有改变 `i` 的值，仍然是1。然后 `++i`，增加1，变为2。最后，`Max(++i, 1)` 的结果就是2和1中的较大者，即2。所以，如果我们忽略未定义行为，这段代码的输出应该是2。

然而，实际的结果可能取决于编译器如何处理这个未定义的行为。在某些编译器上，`i = i++;` 可能使 `i` 变为2，这将导致输出为3。这也是为什么在C++编程中，我们应该避免使用这种形式的代码。

根据题目的选项，答案应该是 C. 3，这可能意味着题目的设定或编译器选择了这种行为。不过这是一个很不好的习题，因为它涉及到了C++中的未定义行为。

# 5
C++中函数重载的实现原理是什么？

A. 通过传入参数的类型不同来区分不同函数；

B. 通过函数名不同来区分不同函数；

C. 通过返回值不同来区分不同函数；

D. 通过传入参数的名称不同来区分不同函数。

A 

# 6
以下类定义不能通过编译的是

A.

    class A {
    public:
        void func(int a, int b, int c) {}; 
    };
B.

    class B {
    public:
        void func(int a, int b=1, int c=1){}
    };
C.

    class C {
    public:
        void func(int a=3, int b, int c){}
    };
D.

    class D {
    public:
        void func(int a=3, int b=1, int c=0){}
    };

C 
默认参数必须在最末尾

# 7
【多选】以下哪些描述属于下面代码无法通过编译的原因

class P {
    int data = 1;
    void func(P a);
    int func(int a, int b=1) {data += a - b; return data;}
    int func(int i, int j=2) { data += i + j; return data;}
      int func2(float i) { data += i; return data;}
};
void P::func(P a) { data += a.data; }

int main(){
    P a;
    a.func2(1);
    return 0;
}
A. 没有设置成员变量、成员函数的访问权限；

B. P 中 func(int, int)函数重复定义；

C. 类 P 的 func(P a) 中修改了私有成员变量；

D. main() 函数中调用了 a的私有成员函数。

answer
B. P 中 func(int, int)函数重复定义；
D. main() 函数中调用了 a的私有成员函数。

在这段代码中，B选项正确，因为 `func(int a, int b=1)` 和 `func(int i, int j=2)` 这两个函数被看作是同一个函数，因为它们的参数类型和数量相同，仅参数的默认值不同，而默认值并不是函数签名的一部分，所以编译器会认为这两个函数是重复定义的，因此无法编译。

同样，选项D也是正确的，因为成员变量data和成员函数func2()、func()都默认为private（即默认的访问权限是私有的），在main()函数中不能直接访问类的私有成员，因此a.func2(1)会报错。

选项A错误，因为C++中如果不显式设置成员变量和成员函数的访问权限，那么默认为private。

选项C也是错误的，类的成员函数可以访问该类的所有成员，包括私有成员。所以在func(P a)中修改私有成员变量data是被允许的。

# 8
【多选】关于C++内联函数以下哪一项是正确的？

A、类声明中定义的函数默认为内联函数；

B、内联操作减少了调用内联函数的开销；

C、一些情况下内联函数可以提升程序运行速度；

D、任何标记为inline的函数，编译器都会对函数进行内联化处理。


answer
A、类声明中定义的函数默认为内联函数；

B、内联操作减少了调用内联函数的开销；

C、一些情况下内联函数可以提升程序运行速度；

内联函数是C++为了优化程序性能而提供的一种功能。在函数声明或定义前面加上关键字 `inline`，函数就被声明为内联函数。

选项A正确。在类声明中定义的成员函数，默认为内联函数。

选项B正确。内联函数可以减少函数调用的开销，因为它们在编译时就会被插入到每个调用点，从而避免了函数调用的额外开销。

选项C也是正确的。由于内联函数减少了函数调用的开销，所以在某些情况下，它们可以提升程序的运行速度。但是，如果内联函数体很大，那么这可能会导致代码膨胀，可能反而会降低程序的运行速度。所以，只有在函数体非常小的情况下，才建议使用内联函数。

对于选项D，虽然 `inline` 关键字是向编译器发出的一种建议，要求它尽可能地将函数调用替换为函数体，但是编译器并不总是遵守这个建议。如果函数体很大，或者函数包含循环、递归、switch语句或goto语句等复杂结构，那么编译器可能会忽略 `inline` 关键字，而不进行内联化处理。所以选项D是错误的。

























